(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{282:function(t,r,e){"use strict";e.r(r);var a=e(14),o=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"android-注入的三种注入方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#android-注入的三种注入方式"}},[t._v("#")]),t._v(" Android 注入的三种注入方式")]),t._v(" "),r("h2",{attrs:{id:"ptrace注入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ptrace注入"}},[t._v("#")]),t._v(" ptrace注入")]),t._v(" "),r("blockquote",[r("p",[t._v("ptrace 是 Linux 内核提供的一个系统调用，旨在允许一个进程监控和控制另一个进程的执行。\nptrace 设计的主要目的是为了支持调试器（如 GDB）的实现。通过 ptrace，调试器可以监控被调试进程的系统调用、信号处理、内存读写、寄存器值等信息，\n以及控制进程的执行，如单步执行、设置断点、修改内存等。\n这样，调试器就可以在进程执行过程中进行调试、跟踪和分析，帮助开发人员定位和解决问题。\n除了调试器，ptrace 还被广泛用于其他系统工具和应用程序的实现，如性能分析器、安全工具、虚拟化等。")])]),t._v(" "),r("p",[t._v("ptrace在设计之初就是为了监控被调试的进程，所以我们可以利用ptrace来实现注入。\n"),r("strong",[t._v("(使用ptrace注入需要root权限)")]),t._v("\n实现可以看看这些文章：\n"),r("a",{attrs:{href:"https://juejin.cn/post/6984995491121463304",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文带你实现android的ptrace注入"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"http://kiya.studio/2015/12/23/hook-call-function-in-so/",target:"_blank",rel:"noopener noreferrer"}},[t._v("hook - Android ARM下的的so注入"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"zygote注入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zygote注入"}},[t._v("#")]),t._v(" zygote注入")]),t._v(" "),r("p",[t._v("zygote注入是利用了android系统的zygote进程，zygote进程是android系统启动时创建的第一个进程，应用进程都是由其fork出来，是所有应用进程的父进程。\nzygote注入对比ptrace注入，ptrace 操作需要在目标进程中执行，因此容易受到目标进程的保护机制的限制，\nzygote 注入时注入操作可以在应用程序启动之前完成，不受目标进程的保护机制的限制。\n"),r("a",{attrs:{href:"https://juejin.cn/post/6990166361508495391",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文带你掌握android的zygote注入"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"elf-so-注入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#elf-so-注入"}},[t._v("#")]),t._v(" ELF(so)注入")]),t._v(" "),r("p",[t._v("修改ELF文件实现so文件注入实现原理为：\n通过修改 Program Header Table中的依赖库信息，添加自定义的so文件信息，APP进程运行加载被该修改过的ELF文件，它也同时会加载并运行自定义的so文件。\n需要对目标apk进行重新打包")]),t._v(" "),r("h2",{attrs:{id:"其它"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[t._v("#")]),t._v(" 其它")]),t._v(" "),r("p",[t._v("几个实现注入的项目：\n"),r("a",{attrs:{href:"https://github.com/shunix/AndroidGotHook",target:"_blank",rel:"noopener noreferrer"}},[t._v("shunix/AndroidGotHook"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://github.com/kiyadesu/Android",target:"_blank",rel:"noopener noreferrer"}},[t._v("kiyadesu/Android"),r("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=o.exports}}]);